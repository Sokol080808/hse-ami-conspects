\section{Вступление}

Сложность некоторых основных алгоритмов:
\begin{itemize}
    \item
        Логарифм

        \( q \geq 2 \)

        \( Lq(n) = \left\lfloor \log_q n \right\rfloor + 1 \)

        \( Lq(0) = 1 \)

        \( Lq(n) = O(Lq'(n)) \)
    \item
        Сложение

        \( a + b \) за \( O(\max(L(a), L(b))) \)
    \item
        Умножение

        \( M(n) = O(n^2) \) --- столбик

        \( M(n) = O(n^{\log_2 3}) \) --- алгоритм Карацубы

        \( M(n) = O_{\varepsilon} (n^{1 + \varepsilon}) \) --- алгоритм Тома-Кука

        \( M(n) = O(n \log n \log \log n) \) --- алгоритм Шенхаге-Штрассена

        \( M(n) = O(n \log n) \) (2019) --- чтобы обогнать предыдущий алгоритм, нужно число порядка \( \log n = 2^{7 \cdot 10^{38}} \)
\end{itemize}

\newpage

\section{Алгоритм Евклида}

\begin{defn}{}{}
    \( a_1, \ldots, a_n \in \ZZ \) не равные одновременно \( 0 \)

    Тогда их НОД-ом называется наибольшее число \( d \), которое делит их всех, и обозначается \( (a_1, \ldots, a_n) \)
\end{defn}

\( (a, b) = ? \)

\( a = bq + r \), \( 0 \leq r < b \)

\( (a, b) = (b, r) \)

Остается сделать так несколько раз:
\begin{gather*}
    \begin{cases}
        m_0 = a_0 m_1 + m_2
        \\
        m_1 = a_1 m_2 + m_3
        \\
        \ldots
        \\
        m_{k - 1} = a_{k - 2} m_{k - 1} + m_k
        \\
        m_{k - 1} = a_{k - 1} m_k
        \\
        m_k = d
    \end{cases}
    \quad
    m_1 > m_2 > \ldots > m_k > 0
\end{gather*}

\begin{lemma}{}{}
    Пусть \( m_0 \geq m_1 \), тогда \( k = O(\log m_1) \)
\end{lemma}

Действительно: \( m_{i - 1} = a_{i - 1} m_i + m_{i + 1} \geq m_i + m_{i + 1} \geq 2 m_{i + 1} \)

Нетрудно убедиться, что взятие модуля через деление в столбик занимает \( O(L(b) \cdot (L(q) + 1)) = O(L(b) (L(a) - L(b) + 1)) \)

\begin{thrm}{}{}
    Сложность алгоритма Евклида, примененного к числам \( a, b \) с длинами \( L(a), L(b) \leq n \) есть \( O(n^2) \)
\end{thrm}
\begin{gather*}
    L(m_1) (L(m_0) - L(m_1) + 1) + L(m_2) (L(m_1) - L(m_2) + 1) + \ldots
    \leq
    \\
    \leq
    L(m_1) (L(m_0) - L(m_1) + 1 + L(m_1) - L(m_2) + 1 + \ldots)
    \leq
    \\
    \leq
    L(m_1) (L(m_0) + k)
    =
    O(L(m_1) L(m_0))
\end{gather*}

\begin{remark}{}{}
    Существуют более быстрые варианты алгоритма Евклида

    На сегодняшний день известна оценка сложности \( O(M(n) \log n) \)

    С алгоритмом Шенхаге-Штрассена, получим \( O(n \log^2 n \log \log n) \)
\end{remark}

\section{Группы, кольца и поля}

\begin{defn}{Группа}{}
    Множество \( (G, *) \) называется группой, если выполняется \( 3 \) свойства:
    \begin{enumerate}
        \item
            \( (a * b) * c = a * (b * c) \) --- ассоциативность
        \item
            \( \exists e : a * e = e * a = a \) --- нейтральный элемент
        \item
            \( \forall a \in G \ \exists b : a * b = b * a = e \) --- обратный элемент
    \end{enumerate}
\end{defn}

\begin{example}{}{}
    \begin{itemize}
        \item
            \( G = \{ e \} \)
        \item
            \( G = \{ \ZZ, + \} \)
        \item
            \( G = \{ R^*, \cdot \} \) --- действительные числа без нуля
        \item
            \( Isom(E^2) \) --- движения плоскости (\( E^2 = \RR^2 \) --- Евклидова плоскость)
        \item
            \( S_n \) --- множество перестановок
    \end{itemize}
\end{example}

\begin{defn}{Абелева группа}{}
    Если \( \forall a, b \in G \) верно \( a * b = b * a \), группа называется коммутативной или абелевой.
\end{defn}

\begin{defn}{Кольцо}{}
    Множество \( R \) с бинарными операциям \( + \) и \( \cdot \) называется кольцом, если:
    \begin{enumerate}
        \item
            \( (R, +) \) --- абелева группа
        \item
            \( a \cdot (b \cdot c) = (a \cdot b) \cdot c \) --- ассоциативность умножения
        \item
            \( a \cdot (b + c) = a \cdot b + a \cdot c \) и \( (b + c) a = b \cdot a + c \cdot a \) --- дистрибутивность
    \end{enumerate}
\end{defn}

\begin{example}{}{}
    \begin{itemize}
        \item
            \( R \) --- кольцо, тогда \( R[x] \) --- тоже кольцо
        \item
            \( R = \{ 0 \} \)
        \item
            \( (\ZZ, +, \cdot), (\RR, +, \cdot), (M_n(\RR), +, \cdot) \)
        \item
            \( \ZZ_m \) --- кольцо вычетов по \( \mod m \)
        \item
            \( \RR[[x]] \) --- кольцо формальных степенных рядов над \( \RR \)
    \end{itemize}
\end{example}

\begin{defn}{}{}
    \begin{enumerate}
        \item
            Если \( \exists 1 \in R : 1 \cdot a = a \cdot 1 = a \), то \( R \) называют кольцом с единицей
        \item
            Если \( \forall a, b \in R \) \( a \cdot b = b \cdot a \), то \( R \) называют коммутативным кольцом
    \end{enumerate}
\end{defn}

\begin{example}{}{}
    \( 2 \ZZ = \{ 2a : a \in \ZZ \} \) --- кольцо без \( 1 \)
\end{example}

\begin{defn}{}{}
    Если \( R \) --- кольцо с \( 1 \), то \( a \in R \) называют обратимым элементом, если \( \exists b : a \cdot b = 1 = b \cdot a \)
\end{defn}

\begin{defn}{Поле}{}
    Если в кольце \( R \) с \( 1 \) любой ненулевой элемент обратим, то \( R \) называют полем
\end{defn}

\begin{example}{Поля}{}
    \( \CC, \RR, \QQ \)
\end{example}

\begin{example}{Кольца, не являющиеся полями}{}
    \( M_n(\RR), 2\ZZ, \RR[x], \RR[[x]] \)
\end{example}

\begin{thrm}{Основная теорема арифметики}{}
    Произвольное натуральное число \( n > 1 \) единственным образом (с точностью до порядка сомножителей)
    раскладывается в произведение простых:
    \[
        n = p_1^{\alpha_1} \ldots p_s^{\alpha_s}
    \]
\end{thrm}

Существование несложно показать по индукции:
если \( n \) не простое, то \( n = ab \), где \( a, b < n \),
после чего применяем предположение индукции.

Единственность покажем от противного.
Пусть \( n \) --- наименьшее число, обладающее двумя разложениями:
\[
    n = p_1^{\alpha_1} \ldots p_s^{\alpha_s} = q_1^{\beta_1} \ldots q_t^{\beta_t}, \text{причем \( p_i \neq q_j \)}
\]

\newpage

\begin{lemma}{Лемма Евклида}{}
    \( a \: | \: bc, (a, b) = 1 \Rightarrow a \: | \: c \)
\end{lemma}

С помощью расширенного алгоритма Евклида (лемма о линейном представление НОД) получим \( au + bv = 1 \)
\begin{gather*}
    au + bv = 1
    \\
    acu + bcv = c
    \\
    a \: | \: acu, a \: | \: bcv \Rightarrow a \: | \: c
\end{gather*}

Используя лемму выше можно ``отщепляя'' \( q_j \) можно доказать, что \( p_1 | 1 \) --- противоречие.

\begin{example}{}{}
    Не во всех кольцах число раскладывается на простыми единственным способом:
    например, в \( 2\ZZ \) верно \( 30 \cdot 2 = 60 = 6 \cdot 10 \)
\end{example}

\begin{defn}{}{}
    \( m \geq 1 \)

    Числа \( a \) и \( b \) называется сравнимыми по модулю \( m \), если \( a - b \) делится на \( m \)

    Будем обозначать  \( a \equiv b \: (\mod m) \) или \( a \equiv b \: (m) \)
\end{defn}

\begin{defn}{}{}
    Классом вычетов \( \ol{a} \) называется множество (по модулю \( m \))
    \[
        \ol{a} = \{ a + mt \: \vline \: t \in \ZZ \}
    \]
\end{defn}

\newpage

\section{Кольцо \( \ZZ_m \) и группа \( \ZZ_m^* \)}

\subsection{Всякие определения}

\begin{defn}{}{}
    \( \ZZ_m \) --- множество классов вычетов
\end{defn}

\begin{lemma}{Свойство сравнений}{}
    \begin{itemize}
        \item
            \( a \equiv b \: (m), \: c \equiv d \: (m) \Rightarrow a + c \equiv b + d \: (m) \)
        \item
            \( a \equiv b \: (m), \: c \equiv d \: (m) \Rightarrow ac \equiv bd \: (m) \)
        \item
            \( ak \equiv bk \: (m), \: (k, m) = 1 \Rightarrow a \equiv b \: (m) \)
        \item
            \( ak \equiv bk \: (m), \: k \: | \: m \Rightarrow a \equiv b \: (m / k) \)
    \end{itemize}
\end{lemma}

Свойства непосредственно следуют из определения.

\begin{coroll}{}{}
    На \( \ZZ_m \) можно ввести структуру кольца:

    \begin{enumerate}
        \item
            \( \ol{a} + \ol{b} = \ol{a + b} \)
        \item
            \( \ol{a} \cdot \ol{b} = \ol{a \cdot b} \)
    \end{enumerate}

    Получим коммутативное кольцо с \( 1 \)
\end{coroll}

Нужно еще проверить корректность (проверяется ручками):

\begin{enumerate}
    \item
        \( \ol{a_1} = \ol{a_2}, \: \ol{b_1} = \ol{b_2} \)

        Хотим \( \ol{a_1 + b_1} = \ol{a_2 + b_2} \) и \( \ol{a_1 \cdot b_1} = \ol{a_2 \cdot b_2} \).

        Но это сразу следует из свойств сравнений.
    \item
        \( \ol{0} + \ol{a} = \ol{a} + \ol{0} = \ol{a} \)
    \item
        \( \ol{a} + \ol{-a} = \ol{0} \)
    \item
        \( (\ol{a} + \ol{b}) + \ol{c} = \ol{a} + (\ol{b} + \ol{c}) \)
    \item
        \( \ol{a} \cdot \ol{b} = \ol{b} \cdot \ol{a} \)
    \item
        \( \ol{a} (\ol{b} + \ol{c}) = \ol{a} \cdot \ol{b} + \ol{a} \cdot \ol{c} \)
    \item
        \( \ol{1} \cdot \ol{a} = \ol{a} \cdot \ol{1} = \ol{a} \)
    \item
        \( \ol{a} \cdot (\ol{b} + \ol{c}) = (\ol{a} \cdot \ol{b}) \cdot \ol{c} \)
\end{enumerate}


\begin{defn}{}{}
    Пусть \( R \) --- кольцо с \( 1 \), то множество
    \[
        R^* = \{ a \in R \: : \: a \text{--- обратим} \}
    \]

    называется множеством обратимых элементов кольца.
\end{defn}

\begin{lemma}{}{}
    \( R^* \) --- группа по умножению
\end{lemma}

Тоже несложно доказывается:

\( a, b \in R^* \), хотим \( a \cdot b \in R^* \)

\( (a \cdot b)^{-1} = b^{-1} \cdot a^{-1} \)

А ассоциативность следует из ассоциативности в кольце.

\( \ZZ_m^* \) --- группа обратимых элементов кольца \( \ZZ_m \)

\begin{thrm}{}{}
    \( \ZZ_m^* = \{ \ol{a} \in \ZZ_m \: : \: (a, m) = 1 \} \)
\end{thrm}

Пусть \( \ol{a} \in Z_m^* \).

Значит \( \exists b : ab = 1 + mt \Rightarrow (a, m) = 1 \).

Докажем в обратную сторону, пусть \( (a, m) = 1 \).
В таком случае:
\[
    \exists u, v \in \ZZ : au + mv = 1
\]

Перейдя к сравнению получим, что \( au = 1 \), то есть \( \ol{a} \) --- обратим.

\begin{defn}{}{}
    Полной системой вычетов по модулю \( m \) называется набор чисел \( a_1, \ldots, a_m \),
    где из каждого класса вычетов взято ровно одно число.

    Понятно, что на таком наборе можно ввести вышеописанную структуру кольца.
\end{defn}

\begin{example}{}{}
    Зачастую берутся \( \{ 0, 1, \ldots, m \} \)

    Или можно взять наименьшие по модулю:
    \(
        \displaystyle
        \{ -\frac{m - 1}{2}, \ldots, 0, 1, \ldots, \frac{m - 1}{2
        } \}
    \)
\end{example}

\begin{defn}{}{}
    Приведенной системой вычетом по модулю \( m \) называется набор чисел,
    взятых по одному из каждого класса \( \ol{a} \) такого, что \( (a, m) = 1 \).

    Аналогично, на этом можно ввести структуру группы.
\end{defn}

\begin{defn}{}{}
    \( \ZZ_6 = \{ 0, 1, 2, 3, 4, 5 \} \)

    \( \ZZ_6^* = \{ 1, 5 \} \)
\end{defn}

\begin{defn}{}{}
    Функцией Эйлера \( \varphi(m) \) называется \( \left| \ZZ_m^* \right| \)

    (количество натуральных чисел \( \leq m \), взаимно простых с ним)
\end{defn}

\begin{defn}{}{}
    Функция \( f : \NN \to \CC \) называется мультипликативной, если:
    \begin{enumerate}
        \item
            \( f(1) = 1 \)
        \item
            \( \forall m, n \in \NN : (m, n) = 1 \) верно \( f(m) \cdot f(n) = f(m \cdot n) \)
    \end{enumerate}
\end{defn}

\begin{remark}{}{}
    Пусть \( f(mn) = f(m)f(n) \) для всех \( m, n \in \NN \).

    Тогда \( f \) называется вполне мультипликативной.
\end{remark}

\begin{lemma}{}{}
    \( \varphi \) --- мультипликативная функция
\end{lemma}

\begin{coroll}{}{}
    \[
        \varphi(m) = m \prod\limits_{p \: | \: m} \left( 1 - \frac{1}{p} \right)
    \]
\end{coroll}

Докажем лемму:

Пусть \( m = m_1 m_2 \) и \( (m_1, m_2) = 1 \)

\( | Z_m^* | = \varphi(m) = \varphi(m_1 m_2) \)

С другой стороны:
\begin{gather*}
    \forall x \in \ZZ_m \quad x = ym_1 + z \quad 0 \leq y \leq m_2 - 1, 0 \leq z \leq m_1 - 1
    \\
    (x, m) = 1
        \Leftrightarrow
        \begin{cases}
            (x, m_1) = 1
            \\
            (x, m_2) = 1
        \end{cases}
\end{gather*}

Но \( (x, m_1) = 1 \Leftrightarrow (z, m_1) = 1 \), поэтому есть \( \varphi(m_1) \) способов выбрать \( z \).

Если же \( y \) пробегает полную систему вычетов по модулю \( m_2 \), то и \( x = ym_1 + z \)
тоже пробегает полную систему вычетов по модулю \( m_2 \).

Пусть система не полная, тогда:
\begin{gather*}
    y_1 m_1 + z \equiv y_2 m_1 + z \: (m_2)
    \\
    (y_1 - y_2)m_1 \equiv 0 \: (m_2)
    \\
    y_1 - y_2 \equiv 0 \: (m_2)
\end{gather*}

Но все \( y \) различны, значит такого не могло быть.

Значит \( (x, m_2) = 1 \) возможно для \( \varphi(m_2) \) значений \( y \).

Но тогда мы выбираем \( x \) \( \varphi(m_1) \cdot \varphi(m_2) \) способами, что и требовалось доказать.

\begin{thrm}{Теорема Эйлера}{}
    \[
        m \in \NN, (a, m) = 1 \Rightarrow a^\varphi(m) \equiv 1 \: (m)
    \]
\end{thrm}

\begin{thrm}{Малая теорема Ферма}{}
    Это частный случай предыдущей теоремы
    \[
        \text{\( p \) --- простое}, (a, p) = 1 \Rightarrow a^{p - 1} \equiv 1 \: (p)
    \]
\end{thrm}

Пусть \( \{ r_1, r_2, \ldots, r_{\varphi{m}} \} \) --- приведенная система вычетов по модулю \( m \).
Умножим каждое на \( a \), тогда \( \{ a r_1, a r_2, \ldots, a r_{\varphi{m}} \} \) тоже является
приведенной системой вычетов по модулю \( m \):
\begin{gather*}
    a r_1 \equiv a r_2 \: (m)
    \\
    \Updownarrow
    \\
    r_1 \equiv r_2 \: (m)
\end{gather*}

В таком случае:
\begin{gather*}
    r_1 \cdot r_2 \ldots r_{\varphi(m)} \equiv (a r_1) \cdot (a r_2) \ldots (a r_{\varphi(m)}) \: (m)
    \\
    \Updownarrow
    \\
    1 \equiv a^{\varphi(m)} \: (m)
\end{gather*}

\begin{remark}{}{}
    Обратное к МТФ утверждение неверно.

    Например, \( 2^{340} \equiv 1 \: (341) \), но \( 341 = 31 \cdot 11 \)
\end{remark}

\begin{thrm}{Теорема Вильсона}{}
    Если \( p \) --- простое, то \( (p - 1)! \equiv -1 \: (p) \) 
\end{thrm}

Доказывается тем, что обратимые элементы (кроме \( \pm 1 \)) разбиваются на пары.

\begin{remark}{}{}
    На самом деле верно утверждение и в обратную сторону.
\end{remark}

\begin{defn}{}{}
    Пусть \( b > 1 \) --- натуральное.
    Тогда составное число \( m \) называется псевдопростым по основанию \( b \),
    если \( b^{m - 1} \equiv 1 \: (m) \).

    (псевдопростым Ферма по основанию \( b \))
\end{defn}

\begin{example}{}{}
    \( 91 \) является псевдопростым по основанию \( 3 \)
\end{example}

\subsection{Тест Ферма}

Вход: \( n \)

Выход: ``\( n \) --- составное'' или ``\( n \) вероятно простое''

\begin{enumerate}
    \item
        \( b \in_R \{ 2, 3, \ldots, n - 2 \} \) и проверяем \( b^{n - 1} \equiv 1 \: (n) \)
    \item
        Если сравнение нарушается, то \( n \) --- составное,
        иначе ``\( n \) вероятно простое''
\end{enumerate}

\begin{defn}{}{}
    Если \( n \) --- составное и \( \forall a \in \ZZ_n^* \) выполнено \( a^{n - 1} \equiv 1 \: (n) \),
    то такое число называется числом Кармайкла или абсолютно псевдопростым.
\end{defn}

\begin{example}{}{}
    Первое число Кармайкла --- \( 561 \)
\end{example}

\newpage

\subsection{Улучшение теста на простоту (Миллер-Рабин)}

Пусть \( n \) --- нечетное простое.
Разложим в виде \( n - 1 = 2^s \cdot d, \ (d, 2) = 1, \: s \geq 1 \)

\begin{gather*}
    a^{n - 1} - 1 \equiv 0 \: (n)
    \\
    a^{2^s d} - 1 = (a^{2^{s - 1} d} + 1) \cdot (a^{2^{s - 2} d} + 1) \ldots (a^d + 1) (a^d - 1) \equiv 0 \: (n)
\end{gather*}

Получили лемму:
\begin{lemma}{}{}
    Пусть \( p > 2 \) --- простое, \( p - 1 = 2^s d \), \( d \) --- нечетно.

    Тогда:
    \begin{enumerate}
        \item
            Либо \( a^d \equiv 1 \: (p) \)
        \item
            Либо \( \exists r : 0 \leq r \leq s - 1 \), что \( a^{2^r d} \equiv -1 \: (p) \).
    \end{enumerate} ,
\end{lemma}

\begin{defn}{}{}
    Если \( n \) составное, но выполнено одно из условий выше,
    то оно называется сильно псевдопростым по основанию \( a \).
\end{defn}

Такая идея доводится до теста Миллера-Рабина:

Вход: \( n \)

Выход: ``\( n \) --- составное'' или ``\( n \) вероятно простое''

\begin{enumerate}
    \item
        \( b \in_R \{ 2, 3, \ldots, n - 2 \} \) и проверяем \( b^{n - 1} \equiv 1 \: (n) \)

        Проверим два вышеописанных условия на \( p \).
    \item
        Если оба условия неверны, то \( n \) --- составное,
        иначе ``не удалось определить''
    \item
        Повторить \( 1 \)-й шаг несколько раз.
        Если везде ``не удалось определить'',
        то возвращаем ``\( n \) вероятно простое''
\end{enumerate}

\begin{remark}{}{}
    Среди первых \( 25 \cdot 10^9 \) есть \( 13 \) чисел, которые являются сильно псевдопростыми по основаниям \( 2, 3, 5 \).

    Если добавить \( 7, 11 \), то все числа определяются корректно.
\end{remark}

\begin{thrm}{(Рабин)}{}
    \begin{gather*}
        G_n = \{ b \in \ZZ_n^* : \text{\( n \) --- сильно не простое по основанию \( b \)} \}
        \\
        \Downarrow
        \\
        | G_n | \leq \frac{\varphi(n)}{4}
    \end{gather*}
\end{thrm}

\begin{thrm}{}{}
    Для доказательства того, что \( n \) --- простое (если \( n \) простое), то
    нужно проверить сильную псевдопростоту для простых оснований \( b \leq 2 \ln^2 n \)
    при условии GRH (расширенная гипотеза Римана).
\end{thrm}

\begin{thrm}{}{}
    \( \ZZ_m \) --- поле \( \Leftrightarrow \) \( m \) --- простое

    Обычно обозначают \( \mathbb{F}_p \) или \( GF(p) \)
\end{thrm}

Доказательство тривиально.

\newpage

\section{Симметричная и асиметричная криптография}

\subsection{Система Полига-Хеллмана (экспоненциальное шифрование)}

\( m \in \ZZ_p \), \( p \) --- простое.

\( m \) --- message

\( k = (e, d) \) --- key

При этом \( ed \equiv 1 \: (p - 1) \)

\( c \) --- cyphertext (зашифрованный текст)

Enc (encryption), Dec (decryption)

\( c = Enc_e(m) = m^e \mod p \)

\( m = Dec_d(c) = c^d \mod p \)

Хотелось бы \( m = Dec_d ( Enc_e (m) ) \) (и еще желательно \( c = Enc_e ( Dec_d (c) ) \))

Очевидно, что эти равенства выполняются по МТФ.

В общем случае:
\begin{itemize}
    \item
        \( M \) --- множество сообщений
    \item
        \( C \) --- множество шифротекстов
    \item
        \( K \) --- множество всех ключей
    \item
        \( Enc_k \) и \( Dec_k \) --- функции шифрования такие,
        что:
        \begin{gather*}
            Enc_k ( Dec_k (c) ) = c
            \\
            Dec_k ( Enc_k (m) ) = m
        \end{gather*}
\end{itemize}

\newpage

\subsection{RSA}

\( p, q \) --- различные простые.

Найдем \( n = pq \) и посчитаем \( \varphi(n) = (p - 1)(q - 1) \)

Выберем пару экспонент \( (d, e) \) такую, что \( de \equiv 1 \: (\varphi(n)) \)

Пара \( (n, e) \) служит открытым ключом,
а число \( d \) является секретным ключом.

Аналогично \( m, c \in \ZZ_n \), \( Enc_e(m) = m^e \mod n \) и \( Dec_d (c) = c^d \mod n \).

Хотим:
\[
    m^{ed} = m^{1 + \varphi(n) t} \equiv m \: (n)
\]

Если \( (m, n) = 1 \), то верно по теореме Эйлера.

Иначе \( (m, n) \) равен одному из трех чисел: \( p, q, pq \).

Последний случай тривиален, теперь разберем оставшиеся.

Не умаляя общности, пусть \( m \equiv 0 \: (p) \), но \( m \not\equiv 0 \: (q) \):
\begin{gather*}
    m^{1 + (p - 1)(q - 1)t} \equiv 0 \equiv m \: (p)
    \\
    m^{1 + (p - 1)(q - 1)t} \equiv m \: (q) \quad \text{(МТФ)}
\end{gather*}

\begin{remark}{}{}    
    Систему можно взломать, если мы можем разложить \( n \) на простые множители,
    но человечество не умеет быстро такое делать.
\end{remark}

\subsection{Шифровая подпись RSA}

\( A \) --- Алиса, создала \( (n, e, d) \), \( (n, e) \) --- в открытом доступе.

\( m \in \ZZ_n \) --- сообщение для Боба

Алисы посылает пару \( (m, Sign_d (m)) \)

По определению \( Sign_d (m) = Dec_d (m) = m^d \mod n \)

Для проверки подписи необходимо проверить, что \( \left( Sign_d (m) \right)^e \equiv m \: (n) \).

Если сообщение слишком длинное, то можно заменить \( Dec_d(m) \) на \( Dec_d(Hash(m)) \)

\subsection{я запутался, как это называть уже}

\begin{defn}{}{}
    Биективное отображение \( f_k \) называется односторонней функцией
    с секретом, если:
    \begin{enumerate}
        \item
            \( \exists \) полиномиальный алгоритм вычисления \( f_k \).
        \item
            \( \exists \) полиномиальный алгоритм вычисления \( f_k^{-1} \) при известном \( k \)
        \item
            \( \not\exists \) полиномиального алгоритма вычисления \( f_k^{-1} \),
            если \( k \) неизвестно.
    \end{enumerate}
\end{defn}

\begin{defn}{}{}
    Биективное отображение \( f \) называется односторонней функцией,
    если:
    \begin{enumerate}
        \item
            \( \exists \) существует полиномиальный алгоритм вычисления \( f \)
        \item
            \( \not\exists \) не существует полиномиального алгоритма вычисления \( f^{-1} \)
    \end{enumerate}
\end{defn}

\subsection{Слепая подпись RSA}

Алиса (банк) знает: \( (n, e, d) \) --- набор RSA, \( H \) --- хэш-функция

Боб: выбирает \( r \in_R \ZZ_n^* \) и посылает Алисе \( m' = H(m) r^e \mod n \)

Алиса: вычисляет \( \sigma' = (m')^d \mod n \) и посылает Бобу.

Боб: \( \sigma = \sigma' r^{-1} \equiv  H^d (m) \: (n) \)

Проверка подписи: \( \sigma^e \equiv H(m) \: (n) \)

\section{КТО}

Семиклассники доказывают, и вы справитесь.

\section{Изоморфизмы}

\begin{defn}{}{}
    Группы \( (G_1, \cdot) \) и \( (G_2, *) \) изоморфны,
    если существует биективное отображение \( \varphi : G_1 \to G_2 \),
    такое, что \( \varphi(g \cdot h) = \varphi(g) * \varphi(h) \).
\end{defn}

\begin{example}{}{}
    \begin{enumerate}
        \item
            \( (\ZZ, +) \cong (2\ZZ, +) \)
        \item
            \( Sym(\triangle) \cong s_3 \)
    \end{enumerate}
\end{example}

\begin{defn}{}{}
    Кольца \( (R_1, +, \cdot) \) и \( (G_2, \oplus, \odot) \) изоморфны,
    если существует биективное отображение \( \varphi : R_1 \to R_2 \),
    такое, что:
    \begin{enumerate}
        \item
            \( \varphi(g + h) = \varphi(g) \oplus \varphi(h) \).
        \item
            \( \varphi(g \cdot h) = \varphi(g) \odot \varphi(h) \).
    \end{enumerate}
\end{defn}

\begin{defn}{}{}
    Прямое произведение групп \( (G_1, \cdot), (G_2, \circ) \)
    это \( G_1 \times G_2 \) с \( (x_1, x_2) \cdot (y_1, y_2) = (x_1 \cdot x_2, y_1 \circ y_2) \)
\end{defn}

\begin{defn}{}{}
    Прямое произведение колец \( (R_1, +_1, \cdot_1), (R_2, +_2, \cdot_2) \)
    это \( R_1 \times R_2 \) с \( (x_1, x_2) + (y_1, y_2) = (x_1 +_1 x_2, y_1 +_2 y_2) \)
\end{defn}

\begin{thrm}{}{}
    \( m_1, \ldots, m_n \) --- попарно взаимнопростые \( m = m_1 \cdot \ldots \cdot m_n \)

    Тогда \( F : x \in \ZZ_m \to (x \mod m_1, \ldots, x \mod m_n) \in \ZZ_{m_1} \times \ldots \times \ZZ_{m_n} \)
\end{thrm}

\begin{coroll}{}{}
    \( \ZZ_m^* \cong \ZZ_{m_1}^* \times \ldots \times \ZZ_{m_n}^* \)

    \( \varphi(m) = \varphi(m_1) \cdot \ldots \cdot \varphi(m_n) \)
\end{coroll}

\newpage

\section{Многочлены}

\begin{defn}{}{}
    Пусть \( R \) --- кольцо \( a, b \in R \), \( a, b \neq 0 \) и \( ab = 0 \).
    В таком случае \( a \) и \( b \) называются делителями нуля.
\end{defn}

Это будет мешать жить, поэтому многочлены нужно рассматривать над полем.

Если \( F \) --- поле, \( P(x), Q(x) \in F[x] \), то \( \deg P(x) Q(x) = \deg P(x) + \deg Q(x) \)

\begin{thrm}{}{}
    \begin{gather*}
        \text{
            \( P(x), Q(x) \in F[x] \), \( F \) --- поле, \( \deg Q(x) > 0 \)
        }
        \\
        \exists! T(x), R(x) \in F(x) : P(x) = Q(x) T(x) + R(x) \quad \deg R(x) < \deg Q(x)
    \end{gather*}
\end{thrm}

Доказательство:
\begin{itemize}
    \item
        Существование

        Делим в столбик.
    \item
        Единственность

        \begin{gather*}
            Q(x) T_1 (x) + R_1 (x) = Q(x) T_2 (x) + R_2 (x)
            \\
            Q(x) (T_1 (x) - T_2 (x)) = R_2 (x) - R_1 (x)
            \\
            \deg Q(x) (T_1 (x) - T_2 (x)) \geq \deg Q(x) > \deg R_2 (x) - R_1 (x)
        \end{gather*}
\end{itemize}

\begin{thrm}{(Безу)}{}
    \[
        P(x) \mod (x - a) = P(a)
    \]
\end{thrm}

Делим с остатком, ура, сошлось.

\begin{coroll}{}{}
    Многочлен степени \( n \) над полем имеет не более \( n \) корней.
\end{coroll}

\begin{defn}{}{}
    \( F \) --- поле, \( P(x), Q(x) \in F[x] \)

    НОД многочленов \( P(x) \) и \( Q(x) \) называется общий делитель \( T(x) \),
    который делится на все их общие делители.
\end{defn}

\begin{thrm}{}{}
    \( F \) --- поле, \( P(x), Q(x) \in F[x] \), \( P(x), Q(x) \) не равны \( 0 \)
    одновременно. 

    Тогда:
    \begin{enumerate}
        \item
            Корректно определен НОД \( P(x), Q(x) \) \( D(x) \)
        \item
            \(
                \exists U(x), V(x) \in F[x] : D(x) = P(x) U(x) + Q(x) V(x)
            \)
    \end{enumerate}
\end{thrm}

\begin{enumerate}
    \item
        Доказывается алгоритмом Евклида.
        Поскольку множество общих делителей не меняется,
        а в конце мы можем получить НОД,
        НОД существует и для первоначальной пары.
    \item
        Доказывается тоже алгоритмом Евклида, как и для чисел.
\end{enumerate}

\begin{defn}{}{}
    \( F \) --- поле, \( P(x) \in F[x] \)

    \( P(x) \) называют неприводимым, если его нельзя представить в виде
    \( P(x) = P_1 (x) P_2 (x) \), где \( P_1(x), P_2(x) \) не константы.
\end{defn}

\begin{thrm}{}{}
    Произвольный многочлен над произвольным полем единственным образом раскладывается на произведение неприводимых.
\end{thrm}

\begin{defn}{}{}
    \( F \) --- поле \( m_1(x), \ldots, m_n(x) \in F[x] \), любые два взаимнопросты.

    Тогда \( \forall a_1(x) ,\ldots, a_n(x) \in F[x] \: \exists! p(x) : p(x) \equiv a_i (x) \: (m_i(x)) \)
    и \( \deg p(x) < \deg m_1(x) + \ldots + \deg m_2(x) \).
\end{defn}

Доказывается, например, по индукции, как и обычная КТО.
